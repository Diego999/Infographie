<!doctype html>

<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		
		<link rel="stylesheet" href="css/stylesheet.css">

		<script src="js/commonFunctions.js"></script>	<!-- Example external source -->
		<script src='js/gl-matrix-min.js'></script>		<!-- Matrix Library -->
		<script src='js/webglTools.js'></script>		<!-- Basic WebGL initialization tools -->
		
		<script id="shader-vs" type="x-shader/x-vertex">
		
		////////////////////////////////////////////////
		////            vertex shader               ////
		////////////////////////////////////////////////
		
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		
		uniform mat4 uMVMatrix; 
		uniform mat4 uPMatrix; 
		uniform mat4 uNMatrix; 
		
		uniform vec3 uLightPosition;
		
		varying vec3 vNormal;
		varying vec3 vLightRay;
		varying  vec3 vEyeVec;		
		
		uniform float uShininess;       
	
		// Add some other lights
		uniform vec3 uLightAmbient;
		uniform vec3 uLightDiffuse;	
		uniform vec3 uLightSpecular;		
		
		// Add some material 
		uniform vec3 uMaterialAmbiant;	
		uniform vec3 uMaterialDiffuse;      
		uniform vec3 uMaterialSpecular;   
		
		void main(void) 
		{
			vec4 vertex = uMVMatrix * vec4(aVertexPosition, 1.0);
			vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));
			vec4 light = vec4(uLightPosition,1.0);
			vLightRay = vertex.xyz - light.xyz;
			vEyeVec = -vec3(vertex.xyz);
			
			gl_Position = uPMatrix * vertex;
		}
		</script>
		
		
		<script id="shader-fs" type="x-shader/x-fragment">
			
		////////////////////////////////////////////////
		////          fragment shader               ////
		////////////////////////////////////////////////
		
		#ifdef GL_ES
		precision highp float;
		#endif
		
		uniform float uShininess;       
		
		// Add some other lights
		uniform vec3 uLightAmbient;
		uniform vec3 uLightDiffuse;	
		uniform vec3 uLightSpecular;		
		
		// Add some material 
		uniform vec3 uMaterialAmbiant;	
		uniform vec3 uMaterialDiffuse;      
		uniform vec3 uMaterialSpecular;   
		
		varying vec3 vNormal;
		varying vec3 vLightRay;
		varying vec3 vEyeVec;
		
		void main(void)
		{	
			// Phong shading
			vec3 L = normalize(vLightRay);
			vec3 N = normalize(vNormal);
			
			vec3 la = uLightAmbient*uMaterialAmbiant;
			vec3 ld = vec3(0.0, 0.0, 0.0);
			vec3 ls = vec3(0.0, 0.0, 0.0);
			vec3 color = vec3(0.0, 0.0, 0.0);
			
			float lambertTerm = dot(N,-L);//cos(theta), Lambert's cosine law
			
			if(lambertTerm > 0.0)
			{
				vec3 E = normalize(vEyeVec);
				vec3 R = reflect(L, N);
			
				ld = uLightDiffuse*uMaterialDiffuse*lambertTerm;
				ls = uLightSpecular*uMaterialSpecular*pow( max(dot(R, E), 0.0), uShininess);
			}
			
			color = la + ld + ls;
			gl_FragColor = vec4(color, 1.0);
		}
		</script>

		<script id="shader-control-vs" type="x-shader/x-vertex">
		
		////////////////////////////////////////////////
		////            vertex shader               ////
		////////////////////////////////////////////////
		
		attribute vec3 aVertexPosition;

		uniform mat4 uMVMatrix; 
		uniform mat4 uPMatrix;  
		uniform vec3 uControlPointSelected;
		varying vec4 vColor;
		
		void main(void) 
		{
			gl_PointSize = 20.0;
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			
			if(all(equal(uControlPointSelected,aVertexPosition)))
				vColor = vec4(0.0, 1.0, 0.0, 1.0);
			else
				vColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
		</script>
		
		<script id="shader-control-fs" type="x-shader/x-fragment">
			
		////////////////////////////////////////////////
		////          fragment shader               ////
		////////////////////////////////////////////////
		
		#ifdef GL_ES
		precision highp float;
		#endif
		
		varying vec4 vColor;
		
		void main(void)
		{	
			gl_FragColor = vColor;
		}
		</script>
		
		<script>
			
			////////////////////////////////////////////////
			////         Global JS variables            ////
			////////////////////////////////////////////////
			
			var prgObject = null;
			var prgControl = null;
			var controlPoints = null;
			var originalControlPoints = null;
			var controlPointsNeighbors = null;
			var controlPointSelected = 0;
			
			var rotX = 0.0; //rotation on the X-axis (in degrees) 
			var rotY = 0.0; //rotation on the Y-axis (in degrees)
			
			var dx = 0;
			var dy = 0;
			var dz = 0;
			var deltaXYZ = 0.1;
			
			// Buffers to send data to the graphics card (vertices, indices, color per vertex)
			var vertexBuffer = null;
			var controlPointsBuffer = null;
			var indexBuffer = null;
			var normalsBuffer = null;

			var indices = []; //JavaScript array to store the indices of the polygon
			var vertices = [];
			var originalVertices = [];
			
			var mvMatrix = mat4.create(); // The Model-View matrix
			var pMatrix = mat4.create(); // The projection matrix
			var nMatrix = mat4.create(); // The normal matrix
			
			// rotation matrix
			var rotationMatrix = mat4.create();
			mat4.identity(rotationMatrix);
			
			// variables stores informations about translation, rotations and mouse states.
			var leftMouseDown = false;
			var rightMouseDown = false;
			var lastMouseX = null;
			var lastMouseY = null;
			var moveXInWorld = 0;
			var moveYInWorld = 0;
			var lastRightMouseX = 0;
			var lastRightMouseY = 0;
			
			var distance = -2;
			
			
			////////////////////////////////////////////////
			////              Model Loader              ////
			////////////////////////////////////////////////
			
			// Executes a http request via ajax, to load a model ressource.
			function loadModel(filename){
			    var request = new XMLHttpRequest();
			    console.info('Requesting ' + filename);
			    request.open("GET",filename);
			    
			    request.onreadystatechange = function() {
			      if (request.readyState == 4) {
			        if(request.status == 404) {
			            console.info(filename + ' does not exist');
			         }
			        else {
			            handleLoadedModel(filename,JSON.parse(request.responseText));

			        }
			      }
			    }
			    request.send();
			}
			
			// Initializes the buffers with the data loaded via the http request.
			function handleLoadedModel(filename,payload) {			    
			    console.info(filename + ' has been retrieved from the server');
				
				indices = payload.indices;
				//initializes buffers: sends data from the javascript arrays to the graphics card
				vertices = payload.vertices;
				originalVertices = payload.vertices;
				vertexBuffer = getVertexBufferWithVertices(vertices);		
				controlPoints = payload.controlPoints;
				originalControlPoints = payload.controlPoints;
				controlPointsNeighbors = payload.controlPointsNeighbors;
				controlPointsBuffer = getVertexBufferWithVertices(payload.controlPoints);		
				normalsBuffer = getVertexBufferWithVertices(payload.normals);
				indexBuffer = getIndexBufferWithIndices(payload.indices);
				
				 //init lights
				initLights();
				
				//Starts rendering loop, calls drawScene
				renderLoop();				
			}

			//initializes light position and colors
			function initLights(){
				glContext.useProgram(prgObject);
			    glContext.uniform3f(prgObject.lightPositionUniform, 1, 1, 1);
				
			    glContext.uniform3f(prgObject.lightAmbientUniform,0.1,0.1,0.1);
			    glContext.uniform3f(prgObject.lightDiffuseUniform,1.0, 1.0, 1.0);
			    glContext.uniform3f(prgObject.lightSpecularUniform, 0.8, 0.8, 0.8);
				
				glContext.uniform3f(prgObject.materialAmbiantUniform, 1.0, 1.0, 1.0);	
				glContext.uniform3f(prgObject.materialSpecularUniform, 1.0, 1.0, 1.0);	
				glContext.uniform3f(prgObject.materialDiffuseUniform, 0.5, 0.5, 0.5);
				
			    glContext.uniform1f(prgObject.shininessUniform, 24.0);
			}
			
			
			
			////////////////////////////////////////////////
			////              WebGL related             ////
			////////////////////////////////////////////////
			
			function drawScene()
			{
				//light grey background
				glContext.clearColor(0.9, 0.9, 1.0, 1.0); // #EEEEFF
				
				//activate z-buffer
				glContext.enable(glContext.DEPTH_TEST);
				
				//resets color and depth buffer before drawing
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				
				drawSceneInit();
				drawSceneObject();
				drawSceneControl();
			}
			
			function drawSceneInit()
			{
				//defines viewport dimensions based on the webgl canvas size
				glContext.viewport(0, 0, c_width, c_height);
									    
			    mat4.perspective(60, c_width / c_height, 0.1, 100.0, pMatrix);


				//model view matrix:
				mat4.identity(mvMatrix);
				mat4.translate(mvMatrix, [0, -0.4, distance]); 
			
				// apply the a translation on the mvMatrix
				mat4.translate(mvMatrix, [moveXInWorld, moveYInWorld, -4.0 + distance]);
				
				// apply the rotation matrix to the mvMatrix
				mat4.multiply(mvMatrix, rotationMatrix);
				
				mat4.rotate(mvMatrix, degToRad(-10), [0, 1, 0]);
			}
			
			// Draws one image of the scene. If the rendering loop is started, this method is called periodically.
			function drawSceneObject(){
				glContext.useProgram(prgObject);
				//send the projection and model view matrices to the vertex shader
			    glContext.uniformMatrix4fv(prgObject.pMatrixUniform, false, pMatrix);
			    glContext.uniformMatrix4fv(prgObject.mvMatrixUniform, false, mvMatrix);
				
				//calculate and send the normal matrix for shading calculation			    	
			    mat4.set(mvMatrix, nMatrix);
			    mat4.inverse(nMatrix);
			    mat4.transpose(nMatrix);
			    
			    glContext.uniformMatrix4fv(prgObject.nMatrixUniform, false, nMatrix);	

				//1. Sending vertices(1.1), normals(1.2), and indices(1.3) to the Vertex Shader;
				//   then ask Vertex Shader to draw triangles between vertices(1.4)
				//1.1 Send the array of VERTEX specifying that they are each composed of 3 parameters 
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prgObject.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

				//1.2 Send the array of Vertex Normals for shading calculation
				glContext.bindBuffer(glContext.ARRAY_BUFFER, normalsBuffer);
				glContext.vertexAttribPointer(prgObject.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

				//1.3 Send the array of INDEX (1 param. for each => no need of 'vertexAttribPointer')
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
								
				//1.4 Draw as triangles
				glContext.drawElements(glContext.TRIANGLES, indices.length, glContext.UNSIGNED_SHORT,0);			
			}
			
			function drawSceneControl()
			{
				glContext.useProgram(prgControl);
				//send the projection and model view matrices to the vertex shader
			    glContext.uniformMatrix4fv(prgControl.pMatrixUniform, false, pMatrix);
			    glContext.uniformMatrix4fv(prgControl.mvMatrixUniform, false, mvMatrix);
				
				//1. Sending vertices(1.1), normals(1.2), and indices(1.3) to the Vertex Shader;
				//   then ask Vertex Shader to draw triangles between vertices(1.4)
				//1.1 Send the array of VERTEX specifying that they are each composed of 3 parameters 
				glContext.bindBuffer(glContext.ARRAY_BUFFER, controlPointsBuffer);
				glContext.vertexAttribPointer(prgControl.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				point = []
				point.push(controlPoints[controlPointSelected*controlPoints.length/3+0],
							controlPoints[controlPointSelected*controlPoints.length/3+1]
							,controlPoints[controlPointSelected*controlPoints.length/3+2]);
				glContext.uniform3fv(glContext.getUniformLocation(prgControl, 'uControlPointSelected'), point);
				
				//1.3 Send the array of INDEX (1 param. for each => no need of 'vertexAttribPointer')
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
								
				//1.4 Draw as triangles
				glContext.drawArrays(glContext.POINTS, 0, controlPoints.length/3);	
			}
			
			
			// Initializes webgl, shaders, buffers and starts rendering loop
			function initWebGL(){
				glContext = getGLContext('webgl-canvas');
				
				
				//Initializes the program (shaders).
				prgObject = initProgram(initObjectShaderParameters, "shader-fs", "shader-vs");
				prgControl = initProgram(initControlShaderParameters, "shader-control-fs", "shader-control-vs");
				
				//Loads a model from file and initializes the buffers that we are going to use to draw polygons 
				//(vertex buffer, color and index buffer)
				loadModel("models/cube.json");
			}
			
			// gets the sahders uniform and attribute locations
			function initObjectShaderParameters(prg){
				
				prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
			    glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
			    
			    prg.vertexNormalAttribute = glContext.getAttribLocation(prg, "aVertexNormal");
			    glContext.enableVertexAttribArray(prg.vertexNormalAttribute);
			    
				// Uniform:
			    prg.pMatrixUniform             = glContext.getUniformLocation(prg, 'uPMatrix');
			    prg.mvMatrixUniform            = glContext.getUniformLocation(prg, 'uMVMatrix');
			    prg.nMatrixUniform             = glContext.getUniformLocation(prg, 'uNMatrix');
			    
			    prg.lightPositionUniform       = glContext.getUniformLocation(prg, 'uLightPosition');
			    
				prg.shininessUniform           = glContext.getUniformLocation(prg, 'uShininess');
				
			    prg.lightAmbientUniform        = glContext.getUniformLocation(prg, 'uLightAmbient');
			    prg.lightDiffuseUniform        = glContext.getUniformLocation(prg, 'uLightDiffuse');
			    prg.lightSpecularUniform       = glContext.getUniformLocation(prg, 'uLightSpecular');
				
				prg.materialAmbiantUniform     = glContext.getUniformLocation(prg, 'uMaterialAmbiant');
			    prg.materialDiffuseUniform     = glContext.getUniformLocation(prg, 'uMaterialDiffuse');
			    prg.materialSpecularUniform    = glContext.getUniformLocation(prg, 'uMaterialSpecular');
			}
			
			function initControlShaderParameters(prg){
				prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
			    glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
				
				prg.pMatrixUniform             = glContext.getUniformLocation(prg, 'uPMatrix');
			    prg.mvMatrixUniform            = glContext.getUniformLocation(prg, 'uMVMatrix');
			}
			
			////////////////////////////////////////////////
			////         Utility functions              ////
			////////////////////////////////////////////////
			
			//convert degrees to radians
			function degToRad(degrees){
				return( degrees * Math.PI / 180.0 );
			}
			
			function rotateObject(deltaX, deltaY)
			{
				var newRotationMatrix = mat4.create();
				mat4.identity(newRotationMatrix);
				mat4.rotate(newRotationMatrix, degToRad(deltaX / 5), [0, 1, 0]);
				mat4.rotate(newRotationMatrix, degToRad(deltaY / 5), [1, 0, 0]);
	            
				mat4.multiply(newRotationMatrix, rotationMatrix, rotationMatrix);
				lastMouseX = lastMouseX + deltaX;
				lastMouseY = lastMouseY + deltaY;
			}
			
			function checkKey(ev){
				var delta = 20;
				switch(ev.keyCode){
					case 65: // 'a' 
						rotateObject(-delta, 0);
						break;
					case 68: // 'd' 
						rotateObject(+delta, 0);
						break;
					case 87: // 'w'
						rotateObject(0, -delta);
						break; 
					case 83: // 's'
						rotateObject(0, +delta);
						break;
					case 189: // '-' key on mac keyboard
					case 173: // '-' key (from keyboard)
					case 109: // '-' key (from number pad)
						// catch '-' key for the zooom functionaliy
						distance -= 0.1;
						break;
					case 107: // catch '+' key for the zooom functionaliy
					case 49:
						distance += 0.1;
						break;
					case 89://y plan x - decrease
						dx -= deltaXYZ;
						break;
					case 88://x plan x - increase
						dx += deltaXYZ;
						break;
					case 67://c plan y - decrease
						dy -= deltaXYZ;
						break;	
					case 86://v plan y - increase
						dy += deltaXYZ;
						break;
					case 66://b plan z - decrease
						dz -= deltaXYZ;
						break;
					case 78://n plan z - increase
						dz += deltaXYZ;
						break;
					case 77://m
							++controlPointSelected;
							controlPointSelected %= controlPoints.length/3;
						break;
					case 75://k
							if(controlPointSelected == 0)
								controlPointSelected = controlPoints.length/3-1;
							else
								--controlPointSelected;
						break;
					default:
					  console.log("Pressed/Non-treated key :" + ev.keyCode); //--- DEBUG LINE ---
					break;
				}
				applyDeformation(dx,dy,dz);
			}
			
			function norm(v){
				return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
			}
			
			function applyDeformation(dx, dy, dz) {		
				vertices = originalVertices.slice(0);
				controlPoints = originalControlPoints.slice(0);

				c = [controlPoints[controlPointSelected*3+0], controlPoints[controlPointSelected*3+1], controlPoints[controlPointSelected*3+2]];
				d = [dx, dy, dz];
			
				cc = [0,0,0];
				for(var i = 0; i < cc.length;++i)
					cc[i] = c[i] + d[i];
					
				neighbors = controlPointsNeighbors[controlPointSelected];
				neighborsNew = [];
				neighborsCopy = [];
				
				//Compute the deformation for the neighborhood
				for(var j = 0; j < neighbors.length; ++j)
				{
					pi = [vertices[neighbors[j]*3+0], vertices[neighbors[j]*3+1], vertices[neighbors[j]*3+2]];
					pic = [0,0,0];
					picc = [0,0,0];
					pii = [0,0,0];
					
					for(var i = 0; i < pic.length; ++i)
					{
						pic[i] = c[i]-pi[i];
						picc[i] = cc[i]-pi[i];
					}
					
					for(var i = 0; i < pic.length; ++i)
					{
						pii[i] = pi[i] + (norm(d)/norm(pic))*picc[i];
						neighborsNew.push(pii[i]);
						neighborsCopy.push(pi[i]);
					}
				}
				
				//Update the new coordinates
				
				controlPoints[controlPointSelected*3+0] += dx;
				controlPoints[controlPointSelected*3+1] += dy;
				controlPoints[controlPointSelected*3+2] += dz;
								
				for(var i = 0; i < vertices.length/3; ++i)
				{
					for(var j = 0; j < neighbors.length; ++j)
						if( vertices[i*3+0] == neighborsCopy[j*3 + 0] && 
							vertices[i*3+1] == neighborsCopy[j*3 + 1] && 
							vertices[i*3+2] == neighborsCopy[j*3 + 2])
							for(var k = 0; k < 3; ++k)
								vertices[i*3 + k] = neighborsNew[j*3+k];
					//Control point							
					if( vertices[i*3+0] == c[0] && 
						vertices[i*3+1] == c[1] && 
						vertices[i*3+2] == c[2])
						for(var k = 0; k < 3; ++k)
							vertices[i*3 + k] = cc[k];
				}
				
				vertexBuffer = getVertexBufferWithVertices(vertices);		
				controlPointsBuffer = getVertexBufferWithVertices(controlPoints);
			}
			
			function handleMouseDown(event)
			{
				if(event.which == 3 || event.button == 2)
				{
					lastRightMouseX = event.clientX;
					lastRightMouseY = event.clientY;
					rightMouseDown = true;
				}
				else if(event.which == 1 || event.button == 0)
				{
					lastMouseX = event.clientX;
					lastMouseY = event.clientY
					leftMouseDown = true;
				}
			}
			
			function handleMouseUp(event)
			{
				if(event.which == 3 || event.button == 2)
				{
					rightMouseDown = false;
				}
				else if(event.which == 1 || event.button == 0)
				{
					leftMouseDown = false;
				}
			}
			
			function handleMouseMove(event)
			{
				var newX = event.clientX;
				var newY = event.clientY;
	
				if(rightMouseDown)
				{
					var deltaX = newX - lastRightMouseX;
					var deltaY = newY - lastRightMouseY;
					
					moveXInWorld += deltaX/100;
					moveYInWorld -= deltaY/100;
					
					lastRightMouseX = newX;
					lastRightMouseY = newY;
					
				}
				
				if(leftMouseDown)
				{
					var deltaX = newX - lastMouseX;
					var deltaY = newY - lastMouseY;
					
					rotateObject(deltaX, deltaY);
				}
			}
			
			function MouseScroll (event) {
				var rolled = 0;
				if ('wheelDelta' in event) {
					rolled = event.wheelDelta;
				}
				else {  // Firefox
					rolled = event.detail;
				}
				distance += -rolled/20;
			}
	
						
		</script>
	</head>

	<!-- HTML body -->
	<body onload="initWebGL()">
		<script>displayTitle("Eg06-01 : Textured face model", 0,1,1,1);</script>
		<!-- WebGL canvas -->	
		<canvas id="webgl-canvas" width="500" height="500" style="float:left;">
			HTML5 is not supported
		</canvas>
		<div style="float:left;margin-left:25px">
		<p>WRITE DESCRIPTION HERER</p>
		<p>Possible interactions:</p>
        <ul>
			<li>Rotation : Mouse movement (left button down)</li>
			<li>Movin camera : Mouse movement (right button down)</li>
			<li>Zoom : Mouse wheel</li>
			<li>Zoom in : "+" key</li>
			<li>Zoom out : "-" key</li>
			<li>Select the next control point : m</li>
			<li>Select the previous control point : k</li>
			<li>Move the point below the plan x : y</li>
			<li>Move the point above the plan x : x</li>
			<li>Move the point below the plan y : c</li>
			<li>Move the point above the plan y : v</li>
			<li>Move the point below the plan z : b</li>
			<li>Move the point above the plan z : n</li>
        </ul>
		</div>
	</body>
	<script id="code-js" type="text/javascript">
	
		////////////////////////////////////////////////
		////      JS action initialisation          ////
		////////////////////////////////////////////////
		var canvas = document.getElementById ("webgl-canvas");
		
		window.onkeydown = checkKey;
		canvas.onmousedown = handleMouseDown;
		document.onmouseup = handleMouseUp;
		document.onmousemove = handleMouseMove;	
		
		if (canvas.addEventListener) {    // all browsers except IE before version 9
			// Internet Explorer, Opera, Google Chrome and Safari
			canvas.addEventListener ("mousewheel", MouseScroll, false);
			// Firefox
			canvas.addEventListener ("DOMMouseScroll", MouseScroll, false);
		}
		else {
			if (canvas.attachEvent) { // IE before version 9
				canvas.attachEvent ("onmousewheel", MouseScroll);
			}
		}
	</script>
</html>